# 상태 패턴 State Pattern

<br>

- 상태를 별도의 클래스로 캡슐화하고 현재 상태를 나타내는 객체에 행동을 위임함
    
    → 객체의 내부 상태가 변경될 때 행동도 변경됨
    
- 마치 객체의 클래스가 바뀌는 것과 같은 결과를 얻을 수 있음

<br>

### 구조

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c50b569-e567-470e-9354-1915ae84cad7/1065e9e7-555b-46b9-8969-c63a664dac2f/Untitled.png)

- `Context` 클래스
    - 여러 가지 내부 상태가 들어있을 수 있음
    - `request()` 메소드가 호출되면 그 작업은 상태 객체에 맡겨짐
- `State` 클래스
    - 모든 구상 상태 클래스의 공통 인터페이스를 정의함

<br><br>

## 상태 패턴과 전략 패턴

- 클래스 다이어그램이 같음

<br>

### 상태 패턴

- 상태 객체에 일련의 행동이 캡슐화됨
- 클라이언트는 상태 객체를 몰라도 됨
- `Context` 객체에 수많은 조건문을 넣는 대신 사용
- `Context` 객체 생성 시 초기 상태를 지정하면 그 후로는 `Context` 객체가 자기 상태를 변경함

<br>

### 전략 패턴

- 일반적으로 클라이언트가 `Context` 객체에게 어떤 전략을 사용할지 지정해줌
- 서브클래스를 만드는 방법을 대신해서 유연성을 극대화하는 용도로 쓰임
    - 구성으로 행동을 정의하는 객체를 유연하게 바꿈

<br><br>

## 핵심 정리

- `Context`에서 상태 전환이 고정되어 있으면 상태 전환 흐름을 결정하는 코드를 `Context`에 넣어도 됨
    - 상태 전환이 동적으로 결정되는 경우 `State` 클래스 내에서 처리하는 것이 좋음
    - 상태 전환 코드를 상태 클래스에 넣으면 `State` 클래스 사이에 의존성이 생기는 단점 → `getter` 메소드로 의존성 최소화
- 디자인에 필요한 클래스 개수가 늘어나지만 유연성 향상을 위한 비용이라고 생각
- `State` 클래스를 여러 `Context` 객체의 인스턴스에서 공유하도록 디자인할 수 있음
    - 상태를 공유할 때는 일반적으로 각 상태를 정적 인스턴스 변수에 할당하는 방법 사용
    - 상태 객체에서 `Context`에 있는 메소드 또는 인스턴스 변수를 활용해야 한다면 각 `handle()` 메소드에 `Context` 객체의 레퍼런스도 전달해야 함
