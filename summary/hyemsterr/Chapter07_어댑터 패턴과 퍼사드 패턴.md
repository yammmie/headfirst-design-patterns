# 어댑터 패턴이란?

- 특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환한다.
- 인터페이스가 호환되지 않아 같이 쓸 수 없었던 클래스를 사용할 수 있게 도와준다.
- 어댑터는 클라이언트가 요구하는 인터페이스를 구현하고, 실제 작업을 수행하는 객체를 감싸 인터페이스를 제공한다.

## 객체 어댑터

- **객체 조합(composition)**을 사용하여 어댑터를 구현한다.
    - 어댑터 클래스는 타겟 인터페이스를 구현하고, 어댑터가 감싸는 실제 객체를 참조로 갖는다.
- 새로운 어댑터를 추가하여 쉽게 확장할 수 있다.
- 어댑티 클래스의 변경 없이 어댑터를 추가할 수 있다.

## 클래스 어댑터

- **다중 상속**을 사용하여 어댑터를 구현한다.
    - 어댑터 클래스는 타겟 인터페이스를 구현하고, 어댑터 클래스를 상속한다.
- 어댑터 클래스의 메서드를 직접 오버라이드하여 동작을 변경할 수 있다.
- 상속을 통해 구현하므로 코드가 간결해진다.

## 데코레이터 패턴 VS 어댑터 패턴 비교

- 두 패턴 모두 클래스 기능을 확장하거나 변경하기 위해 사용된다.

### 어댑터 패턴

- 호환되지 않는 인터페이스를 가진 두 객체를 연결하는 목적으로 사용한다.
- 클라이언트가 기대하는 인터페이스를 구현하고, 실제 객체를 감싸서 위임하는 방식으로 사용한다.

### 데코레이터 패턴

- 객체에 추가적인 기능을 동적으로 추가하기 위한 목적으로 사용한다.
- 원래 객체를 감싸고, 동일한 인터페이스를 구현하여 추가 기능을 제공하는 방식으로 사용한다.

→ 어댑터 패턴은 인터페이스의 호환성 문제 해결에, 데코레이터 패턴은 기능 확장에 중점을 둔다.

→ 어댑터 패턴은 클라이언트의 요구 인터페이스를 제공해야 하나, 데코레이터 패턴은 인터페이스를 유지하며 기능을 추가한다.

# 퍼사드 패턴이란?

- 서브시스템에 있는 일련의 인터페이스를 통합 인터페이스로 묶어준다.
- 고수준 인터페이스를 정의하여 서브시스템을 편리하게 사용할 수 있도록 한다.
- 복잡한 서브시스템에 대한 접근을 간소화하여 클라이언트가 서브시스템의 세부사항에 얽매이지 않도록 한다.

## 퍼사드 패턴 VS 어댑터 패턴 비교

### 퍼사드 패턴

- 복잡한 서브시스템에 단순화된 인터페이스를 제공하여 사용을 쉽게 하려는 목적으로 사용한다.
- 서브 시스템의 여러 클래스와 상호작용을 단순화하고, 단일 인터페이스를 통해 필요한 기능을 제공한다.

### 어댑터 패턴

- 호환되지 않는 인터페이스를 가진 두 객체를 연결하기 위한 목적으로 사용한다.
- 클라이언트가 기대하는 인터페이스를 구현한다.

→ 퍼사드 패턴은 복잡한 서브시스템을 단순화 하는 데, 어댑터 패턴은 호환되지 않는 인터페이스를 연결하는 데 중점을 둔다.

→ 퍼사드 패턴은 클라이언트가 서브시스템의 복잡성을 모르고 사용할 수 있게 할 때 사용된다.

→ 어댑터 패턴은 클라이언트가 기존 클래스와 호환되지 않는 인터페이스를 사용할 수 있게 할 때 사용된다.

## 최소 지식 원칙(Principle of Least Knowledg)

> 객체가 협력하는 객체에 대해 최소한의 지식만을 가져야 한다.
> 
- 객체는 자신이 직접 생성하거나 소유한 객체, 또는 메서드의 인자로 전달된 객체만 사용해야 한다.
- 객체는 자신이 속한 클래스의 멤버만 접근할 수 있다.
- 다른 객체의 메서드를 호출할 때는 그 객체가 반환한 또 다른 객체의 메서드를 호출하지 않아야 한다.

### 퍼사드 패턴과 최소 지식 원칙

- 퍼사드 클래스는 서브시스템의 세부 사항을 감추고 클라이언트에게 단순한 인터페이스를 제공한다.
- 클라이언트는 서브시스템의 내부 구조를 알 필요 없이 필요한 기능을 사용할 수 있다.
