# 팩토리 패턴 Factory Pattern

<br>

## `new`와 구상

- 구상 클래스의 인스턴스가 생성됨 → 인터페이스가 아닌 특정 구현 사용
- 그럼에도 구상 클래스의 인스턴스를 생성해야 함
- 인터페이스를 바탕으로 만들어진 코드는 **다형성** 덕분에 특정 인터페이스만 구현하면 사용 가능
- 반면 구상 클래스를 많이 사용한 코드는 변경에 닫혀 있으므로 새로운 구상 형식을 써서 확장해야 할 때는 어떻게든 다시 열 수 있어야 함(OCP) → 바뀌는 부분 캡슐화

<br><br>

## 간단한 팩토리 Simple Factory

<img width="712" alt="image" src="https://github.com/you-can-be-ace/headfirst-design-patterns/assets/141018558/cfe44cce-60fc-4e19-a372-97bb8a66156b">

- 팩토리: 객체 생성을 처리하는 클래스
- 디자인 패턴보다는 프로그래밍에서 자주 쓰이는 관용구에 가까움
- **피자 객체 생성 작업을 팩토리 클래스로 캡슐화**하면 구현 변경 시 팩토리 클래스만 고치면 됨
- 팩토리 정적 메소드와 다른 점
    - 정적 메소드를 쓰면 객체 생성 메소드를 실행하기 위해 객체 생성할 필요 X
    - 서브클래스를 만들어서 객체 생성 메소드의 행동 변경 불가능
- **클라이언트인 `PizzaStore`는 `SimplePizzaFactory`로부터 피자 인스턴스를 받게 됨**
- **팩토리에서 생산하는 각 피자는 `Pizza` 인터페이스를 구현해야 하며, 구상 클래스여야 함**
    - 일반적으로 어떤 상위 형식(클래스, 인터페이스)에 있는 구상 클래스는 그 상위 형식의 ‘인터페이스를 구현하는’ 클래스라고 생각하면 됨

<br>

### 여러 개의 팩토리 메소드

- `SimplePizzaFactory`를 삭제하고, 서로 다른 팩토리를 생성한 후, `PizzaStore`에서 적당한 팩토리를 사용하도록 하는 방법
- `PizzaStore`와 피자 제작 코드 전체를 하나로 묶어주는 프레임워크 만들기
    - `PizzaStore`는 추상 클래스가 되고, `createPizza()` 메소드는 추상 메소드로 선언
    - `PizzaStore` 인스턴스를 생성하면서 생성한 팩토리 인스턴스를 인자로 전달함
    - 피자 종류는 서브클래스에서 결정 → 지역별 특성에 맞게 서브클래스에서 `createPizza()` 구현
    - `orderPizza()`는 오버라이드하지 못하도록 `final`로 선언
        - 어떤 서브클래스에서 코드를 실행하고 피자를 만드는지 알 수 없음 = `PizzaStore`와 `Pizza`는 서로 완전히 분리됨

<br><br>

## 팩토리 메소드 패턴 Factory Method Pattern

- **모든 팩토리 패턴은 객체 생성을 캡슐화함**
- 팩토리 메소드 패턴은 **서브클래스에서 어떤 클래스를 만들지 결정함으로써 객체 생성을 캡슐화**함
- 구상 생산자 클래스가 하나밖에 없더라도 팩토리 메소드 패턴은 충분히 유용함
    - 제품을 생산하는 부분과 사용하는 부분을 분리하는 목적
- 팩토리 메소드와 생산자 클래스는 꼭 추상으로 선언하지 않아도 됨
    - 몇몇 간단한 구상 제품은 기본 팩토리 메소드를 정의해서 `Creator`의 서브클래스 없이 만들 수 있음
    - 필수 메소드는 `default`로 선언하면 됨
- 매개변수 팩토리의 형식 안전성을 보장해줄 수 있는 기법
    - 매개변수 형식을 나타내는 객체 생성 or 정적 상수 사용 or `enum` 사용

<br>

### 팩토리 메소드 선언

```java
abstract Product factoryMethod(String type)
```

- 추상 메소드로 선언하여 서브클래스가 객체 생성 책임지도록 함
- 특정 객체를 리턴하고, 그 객체는 보통 슈퍼클래스가 정의한 메소드 내에서 사용됨
- 매개변수로 만들 객체 종류 선택 가능
- 클라이언트에서 실제로 생성되는 구상 객체가 무엇인지 알 수 없게 만드는 역할도 함

<br>

### 구조

<img width="764" alt="image" src="https://github.com/you-can-be-ace/headfirst-design-patterns/assets/141018558/3b84b908-5ab9-41af-9dd1-1bcd8676d833">

- 생산자 클래스 `Creator`
    - 생성자와는 별개로 팩토리 메소드 패턴 속에서 무언가 만드는 역할을 강조

<img width="747" alt="image" src="https://github.com/you-can-be-ace/headfirst-design-patterns/assets/141018558/7867354f-abc2-43b0-a04a-a41d3f6a6344">

- 제품 클래스 `Product`

<img width="804" alt="image" src="https://github.com/you-can-be-ace/headfirst-design-patterns/assets/141018558/aa14fefe-deb5-4163-882d-7e2e592a09e6">

⇒ 생산자 클래스와 거기에 대응되는 제품 클래스는 병렬 계층구조

`Pizza`와 `PizzaStore` 둘 다 추상 클래스로 시작하고, 그 클래스를 확장하는 구상 클래스를 갖고 있으며, 구체적인 구현은 구상 클래스들이 책임짐

**팩토리 메소드는 이런 방법을 캡슐화하는 데 있어서 가장 핵심적인 역할을 함**

<br>

### 간단한 팩토리와 팩토리 메소드

| 간단한 팩토리 | 팩토리 메소드 |
| --- | --- |
| 일회용 처방 | 여러 번 재사용 가능한 프레임워크 생성 가능 |
| 생성하는 제품을 마음대로 변경할 수 없음 → 팩토리 메소드만큼 유연하지 X |  |
| 지점 선택이 불가능하고, 서브클래스를 생성해 메뉴 선택만 가능 | 지점 선택 가능 |

<br><br>

## 의존성 뒤집기 원칙 Dependency Inversion Principle

> 📍 디자인 원칙

추상화된 것에 의존하게 만들고 구상 클래스에 의존하지 않게 만든다.
> 
- 추상화를 더 많이 강조함
- 고수준 구성 요소가 저수준 구성 요소에 의존하면 안 되며, 항상 추상화에 의존하게 만들어야 함
    - ‘고수준’ 구성 요소는 다른 ‘저수준’ 구성 요소에 의해 정의되는 행동이 들어있는 구성 요소
- 구상 클래스가 변경되면 슈퍼클래스까지 바꿔야 할 수도 있는 경우, 슈퍼클래스는 구상 클래스 구현에 의존
- **팩토리 메소드 패턴을 적용하면 고수준 구성 요소인 `PizzaStore`와 저수준 구성 요소인 피자 객체 모두가 추상 클래스인  `Pizza`에 의존하게 됨**

<br>

### 지키는 방법

- 변수에 구상 클래스의 레퍼런스를 저장하지 말 것
- 구상 클래스에서 유도된 클래스를 만들지 말 것
- 베이스 클래스에 이미 구현되어 있는 메소드를 오버라이드하지 말 것

<br><br>

## 추상 팩토리 패턴 Abstract Factory Pattern

- 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 **제품군을 생산**하는 인터페이스를 제공함
- 구상 클래스는 서브클래스에서 생성
- 클라이언트에서 추상 인터페이스로 일련의 제품을 공급받을 수 있는데, 이때 실제로 어떤 제품이 생산되는지 전혀 알 필요 없음 = 분리

<br>

### 추상 팩토리 사용

```java
sauce = ingredientFactory.createSauce();
```

- 모든 지역에서 어떤 팩토리를 사용하든 클래스 그대로 재사용 가능
- 피자마다 클래스를 지역별로 따로 만들 필요 없고, 지역별로 다른 점은 원재료 팩토리에서 처리함
- 피자 생성 시 피자의 원재료를 공급하는 팩토리를 인자로 전달하기만 하면 됨

<br>

### 구조

<img width="896" alt="image" src="https://github.com/you-can-be-ace/headfirst-design-patterns/assets/141018558/995f00bc-6f58-4ebd-9ffd-d32dad45eb0e">

- `AbstractFactory` = `PizzaIngredientFactory`
    - 서로 관련된 제품군을 만드는 방법을 정의하는 추상 인터페이스

- `ConcreteFactory` = `NYPizzaIngredientFactory`, `ChicagoPizzaIngredientFactory`
    - 각 구상 피자 팩토리에서 서로 다른 제품군을 구현함

<br>

### 팩토리 메소드 패턴과 추상 팩토리 패턴

- 추상 팩토리가 일련의 제품을 만드는 데 쓰이는 인터페이스를 정의하기 위해 만들어진 것
- 그 인터페이스에 있는 각 메소드는 구상 제품 생산하는 일을 맡고, 추상 팩토리의 서브클래스를 생성해 각 메소드의 구현을 제공함

⇒ 추상 팩토리 패턴에서 제품 생산하는 메소드를 구현하기 위해 팩토리 메소드를 사용하는 것은 자연스러운 일

| 팩토리 메소드 패턴 | 추상 팩토리 패턴 |
| --- | --- |
| 둘 다 애플리케이션을 특정 구현으로부터 분리함 |  |
| 클래스로 제품 생성 | 객체로 제품 생성 |
| 상속으로 객체 생성 | 구성(composition)으로 객체 생성 |
| 구상 형식을 서브클래스에서 처리해줌 + 자신이 사용할 추상 형식만 알면 됨 → 클라이언트와 구상 형식을 분리하는 역할 | 제품군 만드는 추상 형식 제공 + 제품이 생산되는 방법은 추상 형식의 서브클래스에서 정의 + 인스턴스 생성 후 추상 형식을 써서 만든 코드에 전달 → 클라이언트와 실제 구상 제품 분리 |
| 한 가지 제품만 생산 | 새로운 제품을 추가하려면 인터페이스 변경해야 함 |
| 클라이언트 코드와 인스턴스를 생성할 구상 클래스 분리시켜야 할 때 사용 & 어떤 구상 클래스가 필요할지 미리 알 수 없을 때도 유용 | 클라이언트에서 서로 연관된 일련의 제품을 만들어야 할 때(제품군 생성) 활용 |

<br><br>

## 핵심 정리

- 간단한 팩토리는 디자인 패턴은 아니지만 클라이언트와 구상 클래스를 분리하는 간단한 기법으로 활용 가능
- 팩토리 메소드 패턴은 상속 활용, 객체 생성을 서브클래스에 맡김, 서브클래스는 팩토리 메소드를 구현해 객체 생성
- 추상 팩토리 패턴은 객체 구성 활용, 팩토리 인터페이스에서 선언한 메소드에서 객체 생성 구현됨
- 모든 팩토리 패턴은 애플리케이션의 구상 클래스 의존성을 줄여줌으로써 느슨한 결합을 도움
- 의존성 뒤집기 원칙을 따르면 구상 형식 의존을 피하고 추상화 지향 가능
- 팩토리는 구상 클래스가 아닌 추상 클래스와 인터페이스에 맞춰서 코딩할 수 있게 해줌
