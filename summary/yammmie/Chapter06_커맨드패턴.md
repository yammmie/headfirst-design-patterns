# 커맨드 패턴 Command Pattern

<br>

- 어떤 작업을 요청하는 객체와 그 작업을 처리하는 객체를 분리하는 객체지향 디자인 패턴
- 요청 내역을 객체로 캡슐화해서 객체를 서로 다른 요청 내역에 따라 매개변수화 가능
- 요청을 큐에 저장하거나 로그로 기록하거나 작업 취소 기능 사용 가능

<br><br>

## 작동 원리

<img width="735" alt="image" src="https://github.com/you-can-be-ace/headfirst-design-patterns/assets/141018558/52fae4dc-37b3-449c-ba45-a9158164fcf5">

<br>

### 클라이언트

- 커맨드 객체를 생성해야 함
- 인보커 객체의 `setCommand()` 메소드를 호출하면서 커맨드 객체를 넘겨줌

<br>

### 커맨드

- 커맨드 객체는 리시버의 정보와 행동이 같이 들어있음
- 제공하는 단 하나뿐인 메소드 `execute()`는 행동을 캡슐화하여, 리시버에 있는 특정 행동을 처리함

<br>

### 인보커

- 커맨드 객체의 `execute()` 메소드를 호출하면 리시버에 있는 행동 메소드 호출됨
- 인보커 로딩
    1. 클라이언트에서 커맨드 객체 생성
    2. `setCommand()`를 호출해서 인보커에 커맨드 객체 저장
    3. 나중에 클라이언트에서 인보커에게 그 명령 실행하라고 요청
    
    ⇒ 어떤 명령을 인보커에 로딩한 다음 한 번만 작업을 처리하고 커맨드 객체를 지우도록 할 수도 있고, 저장해둔 명령을 여러 번 수행하게 할 수도 있음
    
<br><br>

## 특징

- 커맨드 객체는 일련의 행동을 특정 리시버와 연결함으로써 요청을 캡슐화함
    - 행동과 리시버를 한 객체에 넣고, `execute()` 메소드 하나만 외부에 공개하는 방법 사용함
    - 밖에서 볼 때는 어떤 객체가 리시버 역할을 하는지, 그 리시버가 어떤 일을 하는지 알 수 없고 **단지 `execute()` 메소드를 호출하면 해당 요청이 처리된다는 사실만 알 수 있음**
- 여러 개의 명령을 매크로로 한 번에 실행할 수 있는 메타 커맨드 패턴도 구현 가능

<br><br>

## `NoCommand` 객체

- 일종의 널 객체(`null object`)
- 널 객체는 딱히 리턴할 객체도 없고 클라이언트가 `null`을 처리하지 않게 하고 싶을 때 활용
- 아직 명령이 할당되지 않은 부분에 `NoCommand` 객체를 넣어 `execute()` 메소드가 호출되어도 문제 없도록 함
- 일종의 디자인 패턴으로 분류하기도 함

<br><br>

## 커맨드 패턴 활용

- 커맨드로 컴퓨테이션의 한 부분(리시버와 일련의 행동)을 패키지로 묶어서 일급 객체 형태로 전달 가능
- 클라이언트 애플리케이션에서 커맨드 객체를 생성한 뒤 오랜 시간이 지나도 그 컴퓨테이션 호출 가능
    - 다른 스레드에서도 호출 가능
- 어떤 애플리케이션은 모든 행동을 기록해 두었다가 애플리케이션이 다운되었을 때 그 행동을 다시 호출해서 복구할 수 있어야 함 → `store()`, `load()`
- 로그 기록은 어떤 명령을 실행하면서 디스크에 실행 히스토리를 기록하고, 애플리케이션이 다운되면 커맨드 객체를 다시 로딩해서 `execute()` 메소드를 자동으로 순서대로 실행하는 방식으로 작동함

<br>

### 예: 작업 큐

- 작업 큐 클래스는 계산 작업을 하는 객체들과 완전히 분리되어 있음
- 커맨드 인터페이스를 구현하는 객체를 큐에 추가함
- 컴퓨테이션을 고정된 개수의 스레드로 제한 가능
- 각 스레드는 우선 `execute()` 메소드를 호출하고 호출이 완료되면 커맨드 객체를 버리고 새로운 커맨드 객체를 가져옴
- 큐에 커맨드 패턴을 구현하는 객체를 넣으면 그 객체를 처리하는 스레드가 생기고 자동으로 `execute()` 메소드가 호출됨

<br>

### 예: 스프레드시드 애플리케이션

- 매번 데이터가 변경될 때마다 디스크에 저장하지 않고, 특정 체크 포인트 이후의 모든 행동을 로그에 기록하는 방식으로 복구 시스템 구축 가능
- 이런 테크닉을 확장해서 일련의 작업에 트랜잭션을 활용해 모든 작업이 완벽하게 처리되도록 하거나, 아무것도 처리되지 않게 롤백되도록 할 수 있음

<br><br>

## 핵심 정리

- 커맨드 패턴을 사용하면 요청하는 객체와 요청을 수행하는 객체 분리 가능
    - 분리하는 과정의 중심에 행동이 들어있는 리시버를 캡슐화하는 커맨드 객체가 있음
- 인보커는 무언가 요청할 때 커맨드 객체의 `execute()` 메소드를 호출함
- 커맨드는 인보커를 매개변수화 가능 → 실행 중에 동적으로 매개변수화 설정 가능
- 커맨드 패턴으로 작업 취소 기능, 로그 및 트랜잭션 시스템 구현 가능
- 매크로 커맨드는 커맨드를 확장해서 여러 개의 커맨드를 한 번에 호출할 수 있게 해주는 가장 간편한 방법
