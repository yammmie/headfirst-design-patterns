# 프록시란?

- **다른 객체에 대한 접근을 제어하기 위해 그 객체의 대리자 역할을 하는 객체**
- 실제 객체와 동일한 인터페이를 구현하며, 클라이언트는 프록시와 실제 객체를 동일한 방법으로 사용할 수 있다.
- 클라이언트는 프록시의 존재를 인식하지 않고, 실제 객체를 사용하는 것처럼 코드를 작성할 수 있다.
- 네트워크 통신과 관련된 저수준 작업은 프록시 객체에서 처리해준다.

# 원격 메소드 호출(RMI, Remote Method Invocation) 과정 🚗
<img width="695" alt="image" src="https://github.com/user-attachments/assets/be533a04-f6c5-4e98-b0fc-049867f8ffe2">

### 클라이언트 힙

- **클라이언트 객체**
    - 로컬 객체(클라이언트 보조 객체)의 메소드만 호출한다.
    - 클라이언트 보조 객체가 실제 서비스를 제공한다고 생각한다.
- **클라이언트 보조 객체 (Proxy)**
    - 클라이언트로 받은 요청을 원격 객체(서버 힙)에 전달한다.
    - 서버에 요청을 보내고, 메소드 호출에 관한 정보를 전달하고, 서버로부터 리턴되는 정보를 기다린다.

### 서버 힙

- **서비스 보조 객체 (Proxy)**
    - 소켓 연결을 통해 클라이언트 보조 객체로부터 요청을 받아오고, 호출 정보를 해석해서 서비스 객체를 호출한다.
- **서비스 객체**
    - 서비스 객체 또한 요청이 원격 클라이언트가 아닌 로컬 객체로부터 들어온다고 생각한다.

### 호출 과정

- **클라이언트 객체 → 클라이언트 보조 객체**의 `doBigThing()` 호출
- **클라이언트 보조 객체 → 서비스 보조 객체**에게 포장된 메소드 호출 정보 전달
- **서비스 보조 객체 → 서비스 객체**의 진짜 메소드 호출 (`doBigThing()`)
- **서비스 객체 → 서비스 보조 객체**에게 결과 리턴
- **서비스 보조 객체 → 클라이언트 보조 객체**에게 포장된 결과 리턴
- **클라이언트 보조 객체 → 클라이언트 객체**에게 해석된 결과 리턴

### ☕️ Java의 RMI

- 자바의 `java.rmi.Remote` 클래스에서 원격 메소드 호출 기능을 제공해준다.
- RMI가 클라이언트와 서비스 보조 객체를 만들어주기 때문에 네트워킹 및 입출력 코드를 직접 작성하지 않아도 된다.
- 클라이언트는 로컬 JVM의 메소드를 호출하듯이 원격 메소드를 호출할 수 있다.
- RMI에서 클라이언트 보조 객체는 **Stub**, 서비스 보조 객체는 **Skeleton**이라고 부른다.

# 원격 서비스 구현하기

### 1단계. 원격 인터페이스 생성하기

```java
import java.rmi.*;

public interface MyRemote extends Remote {
	public String sayHello() throws RemoteException;
}
```

- `java.rmi.Remote` 클래스를 확장한다.
- 모든 원격 메소드 호출은 위험이 따르는 것으로 간주하고 모든 메소드에서 RemoteException을 던지도록 선언한다.
- 인자와 리턴값은 반드시 Primitive or Serializable 형식으로 선언해야한다.

### 2단계. 서비스 구현 클래스 생성하기

```java
public class MyRemoteImpl extends UnicastRemoteObject implements MyRemote {
	public MyRemoteImpl() throws RemoteException{}
}
```

- 서비스 클래스에 원격 인터페이스(`MyRemote`)를 구현한다.
- 원격 객체 기능을 추가하기 위해 `UnicastRemoteObject`를 확장한다.

```java
try {
		MyRemote service = new MyRemoteImpl();
		Naming.rebind("RemoteHello", service);
	} catch(Exception e) {
	}
```

- 서비스를 RMI 레지스트리에 등록해서 원격 서비스를 원격 클라이언트에서 쓸 수 있는 상태로 만든다.
- 서비스를 구현한 객체를 등록하면 RMI 시스템은 레지스트리에 스텁을 등록한다.

### 3단계. RMI 레지스트리(rmiregistry) 실행하기

- 터미널을 띄워 `rmiregistry`를 실행한다.

### 4단계. 원격 서비스 실행하기

- 다른 터미널을 띄워 서비스(`MyRemoteImpl`)를 실행한다.

# 프록시 패턴이란

> **특정 객체로의 접근을 제어하는 대리인(특정 객체를 대변하는 객체)을 제공하는 패턴**
> 
- 프록시 패턴을 사용하면 원격 객체나 생성하기 힘든 객체, 보안이 중요한 객체와 같은 다른 객체로의 접근을 제어할 수 있다.

### 원격 프록시 vs 가상 프록시

- **원격 프록시**
    - 다른 JVM에 들어있는 객체의 대리인에 해당하는 로컬 객체이다.
    - 프록시의 메소드를 호출하면 그 호출이 네트워크를 타고 결국 원격 객체의 메소드가 호출된다.
- **가상 프록시**
    - 생성하는 데 많은 비용이 드는 객체를 대신하여, 진짜 객체가 필요한 상황이 오기 전까지 객체의 생성을 미룬다.
    - 객체 생성이 끝나면 RealSubject에 직접 요청을 전달한다.

### 동적 프록시와 보호 프록시

- **동적 프록시**
    - 런타임에 인터페이스를 기반으로 객체를 동적으로 생성하는 방법
- **보호 프록시**
    - 클라이언트가 실제 객체에 접근하기 전에 접근 권한을 확인하고 필요에 따라 접근을 제한하는 방법

→ 동적 프록시를 사용하여 보호 프록시의 기능을 구현할 수 있다.

### 그 외 여러 프록시

- **방화벽 프록시**
    - 일련의 네트워크 자원으로의 접근을 제어함으로써 주제를 ‘나쁜’ 클라이언트로부터 보호해준다.
- **스마트 레퍼런스 프록시**
    - 주제가 참조될 때마다 추가 행동을 제공한다. (ex. 객체의 레퍼런스 개수 체크 등)
- **캐싱 프록시**
    - 비용이 많이 드는 작업 결과를 임시로 저장하여 계산 시간과 네트워크 계산을 줄여준다.
- **동기화 프록시**
    - 여러 스레드에서 주제에 접근할 때 안전하게 작업을 처리할 수 있도록 해준다.
- **복잡도 숨김 프록시 (= 퍼사드 프록시)**
    - 복잡한 클래스의 집합으로의 접근을 제어하고, 그 복잡도를 숨겨준다.
- **지연 복사 프록시**
    - 클라이언트에서 필요로 할 때까지 객체가 복사되는 것을 지연시킴으로써 객체의 복사를 제어한다.
    - 변형된 가상 프록시라고 할 수 있다.

# 프록시 패턴 vs 데코레이터 패턴 vs 어댑터 패턴 vs 퍼사드 패턴

### 프록시 패턴

- 다른 객체를 감싸서 접근을 제어한다.

### 데코레이터 패턴

- 다른 객체를 감싸서 새로운 행동을 추가해준다.

### 어댑터 패턴

- 다른 객체를 감싸서 인터페이스를 제공한다.

### 퍼사드 패턴

- 여러 객체를 감싸서 인터페이스를 단순하게 만든다.
