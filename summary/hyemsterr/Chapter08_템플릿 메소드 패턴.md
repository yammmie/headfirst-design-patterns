# 템플릿 메소드 패턴이란?

- 일련의 단계로 알고리즘을 정의한 **템플릿 메소드**를 사용한다.
- 알고리즘의 골격은 슈퍼클래스가 템플릿 메소드로 정의하고, 서브클래스에서는 알고리즘의 일부 단계를 구현한다.
- 알고리즘의 구조는 유지하면서 특정 단계를 서브 클래스에서 재정의한다.

```java
public abstract class CaffeignBeverage {
	final void prepareReceipt() {
		boilWater();
		brew();
		pourInCup();
		addCondiments();
	}
}
```

> **예제 살펴보기**
> 
> - `prepareReceipt()`가 템플릿 메소드이다.
>     - 이것 자체로도 메소드
>     - 어떤 알고리즘의 템플릿 역할

### Hook

- 추상 클래스에서 선언되지만 기본적인 내용만 구현되어 있거나 아무 코드도 들어있지 않은 메소드를 Hook이라고 한다.
- 알고리즘의 특정 단계가 선택적으로 적용된다면 Hook을 사용한다.

```java
public abstract class CaffeignBeverage {
	final void prepareReceipt() {
		boilWater();
		brew();
		pourInCup();
		
		if(customerWantsCondiments()) {
			addCondiments();
		}
	}
	
	boolean customerWantsCondiments() { return true; }
}
```

> **예제 살펴보기**
> 
> - `customerWantsCondiments()`가 Hook이다.
>     - 별 내용이 없는 기본 메소드로 정의해두고, 서브클래스에서 필요할 때 오버라이드 해서 사용한다.

### 템플릿 메소드 패턴의 장점

- 서브클래스에서 코드를 재정의해서 세부적인 로직을 작성할 수 있어 유연하다.
- 알고리즘이 한 군데 모여있기 때문에, 음료 제조 과정을 바꾸고 싶으면 한 군데만 고치면 된다.

# 할리우드 원칙

> *먼저 연락하지 마세요. 저희가 연락드리겠습니다.*
> 
- 저수준 구성 요소가 시스템에 접속할 수 있지만, 언제 어떻게 쓰일지는 고수준 구성요소가 결정한다.
- 저수준 구성 요소는 절대 고수준 구성 요소를 직접 호출할 수 없다.
- **의존성 부패(dependency not)**를 방지할 수 있다.
    - 서로 의존성이 복잡하게 꼬여 있는 상황
    ex) *고수준 요소가 저수준 요소에 의존하고, 그 저수준 요소는 고수준 요소에 의존하고, 그 고수준 요소는 …*

# 템플릿 메소드 패턴 vs 전략 패턴

### 템플릿 메소드 패턴

- 알고리즘의 개요를 정의하고, 진짜 작업 중 일부는 서브클래스에서 처리한다.
- 알고리즘의각 단계마다 다른 구현을 사용하면서도 알고리즘 구조 자체는 그대로 유지할 수 있다.
- 알고리즘 일부를 슈퍼클래스에서 구현한 메소드에 의존한다.

### 전략 패턴

- 일련의 알고리즘군을 정의하고 그 알고리즘들을 서로 바꿔가면서 사용할 수 있게 한다.
- 각 알고리즘은 캡슐화되어 있으므로 클라이언트에서 손쉽게 다른 알고리즘을 사용할 수 있다.
- 알고리즘을 전부 각 객체에서 알아서 구현하기 때문에 의존성이 없다.
